/*
Modern Logic Api

Manage and version your customer decision logic outside of your codebase

API version: 1.0.0
Contact: info@usemodernlogic.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package modern_logic_client

import (
	"bytes"
	_context "context"
	_ioutil "io/ioutil"
	_nethttp "net/http"
	_neturl "net/url"
	"strings"
)

// Linger please
var (
	_ _context.Context
)

// WorkflowsApiService WorkflowsApi service
type WorkflowsApiService service

type ApiWorkflowGetRequest struct {
	ctx _context.Context
	ApiService *WorkflowsApiService
	pageSize *int32
	pageNumber *int32
}

// Number of elements to return (default is 10)
func (r ApiWorkflowGetRequest) PageSize(pageSize int32) ApiWorkflowGetRequest {
	r.pageSize = &pageSize
	return r
}
// Lists are ordered by creation date ascending. To return the first page, set pageNumber to zero
func (r ApiWorkflowGetRequest) PageNumber(pageNumber int32) ApiWorkflowGetRequest {
	r.pageNumber = &pageNumber
	return r
}

func (r ApiWorkflowGetRequest) Execute() (ListResponse, *_nethttp.Response, error) {
	return r.ApiService.WorkflowGetExecute(r)
}

/*
WorkflowGet List Available Workflows

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiWorkflowGetRequest
*/
func (a *WorkflowsApiService) WorkflowGet(ctx _context.Context) ApiWorkflowGetRequest {
	return ApiWorkflowGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListResponse
func (a *WorkflowsApiService) WorkflowGetExecute(r ApiWorkflowGetRequest) (ListResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkflowsApiService.WorkflowGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/workflow"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.pageSize != nil {
		localVarQueryParams.Add("pageSize", parameterToString(*r.pageSize, ""))
	}
	if r.pageNumber != nil {
		localVarQueryParams.Add("pageNumber", parameterToString(*r.pageNumber, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWorkflowWorkflowIDExecutePostRequest struct {
	ctx _context.Context
	ApiService *WorkflowsApiService
	workflowID int32
	requestBody *map[string]interface{}
	v *int32
}

// Execution Information
func (r ApiWorkflowWorkflowIDExecutePostRequest) RequestBody(requestBody map[string]interface{}) ApiWorkflowWorkflowIDExecutePostRequest {
	r.requestBody = &requestBody
	return r
}
// If you want to run a version other then the current production version, you can supply the version number to run.
func (r ApiWorkflowWorkflowIDExecutePostRequest) V(v int32) ApiWorkflowWorkflowIDExecutePostRequest {
	r.v = &v
	return r
}

func (r ApiWorkflowWorkflowIDExecutePostRequest) Execute() (WorkflowExecutionResult, *_nethttp.Response, error) {
	return r.ApiService.WorkflowWorkflowIDExecutePostExecute(r)
}

/*
WorkflowWorkflowIDExecutePost Execute Workflow

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param workflowID Workflow id
 @return ApiWorkflowWorkflowIDExecutePostRequest
*/
func (a *WorkflowsApiService) WorkflowWorkflowIDExecutePost(ctx _context.Context, workflowID int32) ApiWorkflowWorkflowIDExecutePostRequest {
	return ApiWorkflowWorkflowIDExecutePostRequest{
		ApiService: a,
		ctx: ctx,
		workflowID: workflowID,
	}
}

// Execute executes the request
//  @return WorkflowExecutionResult
func (a *WorkflowsApiService) WorkflowWorkflowIDExecutePostExecute(r ApiWorkflowWorkflowIDExecutePostRequest) (WorkflowExecutionResult, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodPost
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  WorkflowExecutionResult
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkflowsApiService.WorkflowWorkflowIDExecutePost")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/workflow/{workflowID}/execute"
	localVarPath = strings.Replace(localVarPath, "{"+"workflowID"+"}", _neturl.PathEscape(parameterToString(r.workflowID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}
	if r.requestBody == nil {
		return localVarReturnValue, nil, reportError("requestBody is required and must be specified")
	}

	if r.v != nil {
		localVarQueryParams.Add("v", parameterToString(*r.v, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.requestBody
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWorkflowWorkflowIDExecutionsGetRequest struct {
	ctx _context.Context
	ApiService *WorkflowsApiService
	workflowID int32
	v *int32
	pageSize *int32
	pageNumber *int32
}

// If you want to return the executions of a particular workflow version instead of all workflows
func (r ApiWorkflowWorkflowIDExecutionsGetRequest) V(v int32) ApiWorkflowWorkflowIDExecutionsGetRequest {
	r.v = &v
	return r
}
// Number of elements to return (default is 10)
func (r ApiWorkflowWorkflowIDExecutionsGetRequest) PageSize(pageSize int32) ApiWorkflowWorkflowIDExecutionsGetRequest {
	r.pageSize = &pageSize
	return r
}
// Lists are ordered by creation date ascending. To return the first page, set pageNumber to zero
func (r ApiWorkflowWorkflowIDExecutionsGetRequest) PageNumber(pageNumber int32) ApiWorkflowWorkflowIDExecutionsGetRequest {
	r.pageNumber = &pageNumber
	return r
}

func (r ApiWorkflowWorkflowIDExecutionsGetRequest) Execute() (ListResponse, *_nethttp.Response, error) {
	return r.ApiService.WorkflowWorkflowIDExecutionsGetExecute(r)
}

/*
WorkflowWorkflowIDExecutionsGet List Workflow Executions

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param workflowID Workflow Id
 @return ApiWorkflowWorkflowIDExecutionsGetRequest
*/
func (a *WorkflowsApiService) WorkflowWorkflowIDExecutionsGet(ctx _context.Context, workflowID int32) ApiWorkflowWorkflowIDExecutionsGetRequest {
	return ApiWorkflowWorkflowIDExecutionsGetRequest{
		ApiService: a,
		ctx: ctx,
		workflowID: workflowID,
	}
}

// Execute executes the request
//  @return ListResponse
func (a *WorkflowsApiService) WorkflowWorkflowIDExecutionsGetExecute(r ApiWorkflowWorkflowIDExecutionsGetRequest) (ListResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkflowsApiService.WorkflowWorkflowIDExecutionsGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/workflow/{workflowID}/executions"
	localVarPath = strings.Replace(localVarPath, "{"+"workflowID"+"}", _neturl.PathEscape(parameterToString(r.workflowID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.v != nil {
		localVarQueryParams.Add("v", parameterToString(*r.v, ""))
	}
	if r.pageSize != nil {
		localVarQueryParams.Add("pageSize", parameterToString(*r.pageSize, ""))
	}
	if r.pageNumber != nil {
		localVarQueryParams.Add("pageNumber", parameterToString(*r.pageNumber, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWorkflowWorkflowIDGetRequest struct {
	ctx _context.Context
	ApiService *WorkflowsApiService
	workflowID int32
}


func (r ApiWorkflowWorkflowIDGetRequest) Execute() (Workflow, *_nethttp.Response, error) {
	return r.ApiService.WorkflowWorkflowIDGetExecute(r)
}

/*
WorkflowWorkflowIDGet Get Workflow Details

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param workflowID Workflow id
 @return ApiWorkflowWorkflowIDGetRequest
*/
func (a *WorkflowsApiService) WorkflowWorkflowIDGet(ctx _context.Context, workflowID int32) ApiWorkflowWorkflowIDGetRequest {
	return ApiWorkflowWorkflowIDGetRequest{
		ApiService: a,
		ctx: ctx,
		workflowID: workflowID,
	}
}

// Execute executes the request
//  @return Workflow
func (a *WorkflowsApiService) WorkflowWorkflowIDGetExecute(r ApiWorkflowWorkflowIDGetRequest) (Workflow, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  Workflow
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkflowsApiService.WorkflowWorkflowIDGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/workflow/{workflowID}"
	localVarPath = strings.Replace(localVarPath, "{"+"workflowID"+"}", _neturl.PathEscape(parameterToString(r.workflowID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWorkflowWorkflowIDVersionsGetRequest struct {
	ctx _context.Context
	ApiService *WorkflowsApiService
	workflowID int32
	pageSize *int32
	pageNumber *int32
}

// Number of elements to return (default is 10)
func (r ApiWorkflowWorkflowIDVersionsGetRequest) PageSize(pageSize int32) ApiWorkflowWorkflowIDVersionsGetRequest {
	r.pageSize = &pageSize
	return r
}
// Lists are ordered by creation date ascending. To return the first page, set pageNumber to zero
func (r ApiWorkflowWorkflowIDVersionsGetRequest) PageNumber(pageNumber int32) ApiWorkflowWorkflowIDVersionsGetRequest {
	r.pageNumber = &pageNumber
	return r
}

func (r ApiWorkflowWorkflowIDVersionsGetRequest) Execute() (ListResponse, *_nethttp.Response, error) {
	return r.ApiService.WorkflowWorkflowIDVersionsGetExecute(r)
}

/*
WorkflowWorkflowIDVersionsGet List Workflow Versions

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param workflowID Workflow id
 @return ApiWorkflowWorkflowIDVersionsGetRequest
*/
func (a *WorkflowsApiService) WorkflowWorkflowIDVersionsGet(ctx _context.Context, workflowID int32) ApiWorkflowWorkflowIDVersionsGetRequest {
	return ApiWorkflowWorkflowIDVersionsGetRequest{
		ApiService: a,
		ctx: ctx,
		workflowID: workflowID,
	}
}

// Execute executes the request
//  @return ListResponse
func (a *WorkflowsApiService) WorkflowWorkflowIDVersionsGetExecute(r ApiWorkflowWorkflowIDVersionsGetRequest) (ListResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkflowsApiService.WorkflowWorkflowIDVersionsGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/workflow/{workflowID}/versions"
	localVarPath = strings.Replace(localVarPath, "{"+"workflowID"+"}", _neturl.PathEscape(parameterToString(r.workflowID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.pageSize != nil {
		localVarQueryParams.Add("pageSize", parameterToString(*r.pageSize, ""))
	}
	if r.pageNumber != nil {
		localVarQueryParams.Add("pageNumber", parameterToString(*r.pageNumber, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiWorkflowWorkflowIDWebhooksGetRequest struct {
	ctx _context.Context
	ApiService *WorkflowsApiService
	workflowID int32
	pageSize *int32
	pageNumber *int32
}

// Number of elements to return (default is 10)
func (r ApiWorkflowWorkflowIDWebhooksGetRequest) PageSize(pageSize int32) ApiWorkflowWorkflowIDWebhooksGetRequest {
	r.pageSize = &pageSize
	return r
}
// Lists are ordered by creation date ascending. To return the first page, set pageNumber to zero
func (r ApiWorkflowWorkflowIDWebhooksGetRequest) PageNumber(pageNumber int32) ApiWorkflowWorkflowIDWebhooksGetRequest {
	r.pageNumber = &pageNumber
	return r
}

func (r ApiWorkflowWorkflowIDWebhooksGetRequest) Execute() (ListResponse, *_nethttp.Response, error) {
	return r.ApiService.WorkflowWorkflowIDWebhooksGetExecute(r)
}

/*
WorkflowWorkflowIDWebhooksGet List Active Callbacks

 @param ctx _context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param workflowID Workflow ID
 @return ApiWorkflowWorkflowIDWebhooksGetRequest
*/
func (a *WorkflowsApiService) WorkflowWorkflowIDWebhooksGet(ctx _context.Context, workflowID int32) ApiWorkflowWorkflowIDWebhooksGetRequest {
	return ApiWorkflowWorkflowIDWebhooksGetRequest{
		ApiService: a,
		ctx: ctx,
		workflowID: workflowID,
	}
}

// Execute executes the request
//  @return ListResponse
func (a *WorkflowsApiService) WorkflowWorkflowIDWebhooksGetExecute(r ApiWorkflowWorkflowIDWebhooksGetRequest) (ListResponse, *_nethttp.Response, error) {
	var (
		localVarHTTPMethod   = _nethttp.MethodGet
		localVarPostBody     interface{}
		localVarFormFileName string
		localVarFileName     string
		localVarFileBytes    []byte
		localVarReturnValue  ListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "WorkflowsApiService.WorkflowWorkflowIDWebhooksGet")
	if err != nil {
		return localVarReturnValue, nil, GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/workflow/{workflowID}/webhooks"
	localVarPath = strings.Replace(localVarPath, "{"+"workflowID"+"}", _neturl.PathEscape(parameterToString(r.workflowID, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := _neturl.Values{}
	localVarFormParams := _neturl.Values{}

	if r.pageSize != nil {
		localVarQueryParams.Add("pageSize", parameterToString(*r.pageSize, ""))
	}
	if r.pageNumber != nil {
		localVarQueryParams.Add("pageNumber", parameterToString(*r.pageNumber, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, localVarFormFileName, localVarFileName, localVarFileBytes)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := _ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = _ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
